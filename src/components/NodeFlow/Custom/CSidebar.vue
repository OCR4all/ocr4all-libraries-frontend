<template>
  <div ref="el" class="baklava-sidebar" :class="{ '--open': graph.sidebar.visible }" :style="styles">
    <div v-if="resizable" class="__resizer" @mousedown="startResize" />

    <div class="__header text-black dark:text-white">
      <button tabindex="-1" class="__close" @click="close">&times;</button>
      <div class="__node-name">
        <b>{{ node ? node.title : "" }}</b>
      </div>
    </div>

    <h2 class="text-black dark:text-white text-xl">Parameters</h2>
    <div v-for="intf in displayedInterfaces" :key="intf.id" class="__interface text-black dark:text-white" >
      <component :is="intf.component" v-model="intf.value" :node="node" :intf="intf" />
    </div>
  </div>
</template>

<script lang="ts">
import { computed, defineComponent, ref, toRef } from "vue";
import { useGraph, useViewModel } from "baklavajs";

export default defineComponent({
  setup() {
    const { viewModel } = useViewModel();
    const { graph } = useGraph();

    const el = ref<HTMLElement | null>(null);

    const width = toRef(viewModel.value.settings.sidebar, "width");
    const resizable = computed(() => viewModel.value.settings.sidebar.resizable);

    const node = computed(() => {
      const id = graph.value.sidebar.nodeId;
      return graph.value.nodes.find((x) => x.id === id);
    });

    const styles = computed(() => ({
      width: `${width.value}px`,
    }));

    const displayedInterfaces = computed(() => {
      if (!node.value) {
        return [];
      }
      const allIntfs = [...Object.values(node.value.inputs), ...Object.values(node.value.outputs)];
      return allIntfs.filter((intf) => intf.displayInSidebar && intf.component);
    });

    const close = () => {
      graph.value.sidebar.visible = false;
    };

    const startResize = () => {
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener(
          "mouseup",
          () => {
            window.removeEventListener("mousemove", onMouseMove);
          },
          { once: true },
      );
    };

    const onMouseMove = (event: MouseEvent) => {
      const maxwidth = el.value?.parentElement?.getBoundingClientRect().width ?? 500;
      let newWidth = width.value - event.movementX;
      if (newWidth < 300) {
        newWidth = 300;
      } else if (newWidth > 0.9 * maxwidth) {
        newWidth = 0.9 * maxwidth;
      }
      width.value = newWidth;
    };

    return { el, graph, resizable, node, styles, displayedInterfaces, startResize, close };
  },
});
</script>